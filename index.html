<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Constelação v6 (Multi-Indicadores)</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: sans-serif;
            background-color: #f0f0f0;
        }
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            cursor: grab; /* Default cursor */
        }
        #controls-panel {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 280px; /* Aumentar um pouco? */
            max-height: calc(100vh - 20px);
            overflow-y: auto;
            background-color: rgba(255, 255, 255, 0.92);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 3;
            color: #333;
            display: flex;
            flex-direction: column;
        }
        #controls-panel h3, #controls-panel h4 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
            flex-shrink: 0;
        }
        #controls-panel h4 {
             font-size: 1.0em;
             margin-top: 10px; /* Espaço antes de subseções */
             margin-bottom: 10px;
        }
        .control-group {
            margin-bottom: 15px;
            flex-shrink: 0;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.9em;
        }
        .control-group input[type="text"],
        .control-group input[type="color"],
        .control-group input[type="range"],
        .control-group button,
        .control-group select {
            width: calc(100% - 16px); /* Ajustar se padding/border mudar */
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9em;
            box-sizing: border-box;
        }
         .control-group input[type="color"] {
            width: 50px;
            height: 30px;
            padding: 2px;
            vertical-align: middle;
            margin-left: 5px;
            display: inline-block;
            width: auto;
         }
         .control-group input[type="range"] {
            padding: 0;
            margin-top: 5px;
            height: 20px;
         }
         .control-group .inline-label { /* Label ao lado do controle */
             display: inline-block;
             margin-right: 5px;
             margin-bottom: 0;
             vertical-align: middle;
         }
         .control-group .value-display { /* Span para mostrar valor do slider */
             font-weight: normal;
             font-size: 0.9em;
             color: #555;
             vertical-align: middle;
             margin-left: 8px;
         }

        .control-group button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .control-group button:hover {
            background-color: #367c39;
        }
         .control-group button.remove-btn {
            background-color: #f44336;
            width: auto; /* Ajustar botões menores */
            padding: 6px 10px;
            font-size: 0.85em;
         }
         .control-group button.remove-btn:hover {
            background-color: #d32f2f;
         }
         .control-group button.action-btn {
            background-color: #007bff;
            margin-top: 5px;
         }
         .control-group button.action-btn:hover {
            background-color: #0056b3;
         }
         .control-group button.secondary-action-btn {
             background-color: #6c757d;
             width: auto;
             padding: 6px 10px;
             font-size: 0.85em;
             margin-right: 5px;
             margin-bottom: 5px;
         }
          .control-group button.secondary-action-btn:hover {
             background-color: #5a6268;
          }

         .control-group button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
         }
        .size-control-label {
            display: inline-block;
            vertical-align: middle;
            margin-right: 10px;
        }

        #selected-info, #indicator-info {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #ccc;
            flex-shrink: 0;
        }
        #selected-info p, #indicator-info p {
            margin: 5px 0;
            font-size: 0.85em;
            line-height: 1.4;
        }
         #selected-info strong, #indicator-info strong {
            color: #0056b3;
         }
        .disclaimer {
            font-size: 0.75em;
            color: #666;
            margin-top: auto;
            padding-top: 10px;
            border-top: 1px dashed #ccc;
            line-height: 1.3;
            flex-shrink: 0;
        }

        /* --- Novos Estilos para Indicadores --- */
        #indicator-controls {
            padding-top: 10px;
            border-top: 1px dashed #ccc; /* Separador visual */
            margin-top: 15px;
        }
         #indicator-controls label {
             font-size: 0.85em; /* Labels menores para controles de indicador */
         }
         #indicator-controls select {
             margin-bottom: 15px; /* Mais espaço após o select */
         }
         #indicator-specific-controls {
            display: none; /* Escondido até um indicador ser selecionado */
         }
         #indicator-specific-controls .control-group {
             margin-bottom: 10px; /* Menos espaço entre controles de indicador */
         }

        /* Painel de Guia (Sem alterações) */
        #guidance-panel {
            position: fixed; top: 10px; right: 10px; width: 300px;
            max-height: calc(100vh - 20px); overflow-y: auto; background-color: rgba(230, 240, 255, 0.95);
            padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.15);
            z-index: 2; color: #224; display: none; flex-direction: column;
        }
        #guidance-panel.visible { display: flex; }
        #guidance-panel h4 { margin-top: 0; margin-bottom: 10px; font-size: 1.05em; color: #003366; border-bottom: 1px solid #aaccff; padding-bottom: 5px; flex-shrink: 0; }
        #guidance-content { font-size: 0.9em; line-height: 1.5; margin-bottom: 15px; flex-grow: 1; overflow-y: auto; }
        #guidance-content ul { padding-left: 20px; margin-top: 5px; }
        #guidance-content li { margin-bottom: 5px; }
        #guidance-navigation { display: flex; justify-content: space-between; margin-top: 10px; flex-shrink: 0; }
        #guidance-navigation button { padding: 6px 12px; font-size: 0.85em; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        #guidance-navigation button:disabled { background-color: #cccccc; cursor: not-allowed; }
        #end-exercise-btn { background-color: #dc3545; }
        #exercise-info { font-size: 0.85em; color: #555; margin-top: 5px; margin-bottom: 10px; padding: 8px; background-color: #e9ecef; border-radius: 4px; }

        /* Modal de Análise Final (Sem alterações) */
        #analysis-modal {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 90%; max-width: 500px; max-height: 80vh; background-color: white;
            border-radius: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.3); z-index: 10;
            padding: 25px; display: none; flex-direction: column;
        }
        #analysis-modal.visible { display: flex; }
        #analysis-modal h4 { margin-top: 0; margin-bottom: 15px; text-align: center; color: #333; border-bottom: 1px solid #eee; padding-bottom: 10px;}
        #analysis-content { overflow-y: auto; margin-bottom: 20px; font-size: 0.9em; line-height: 1.6; color: #444;}
        #analysis-content strong { color: #0056b3; } #analysis-content ul { padding-left: 18px; } #analysis-content li { margin-bottom: 8px; }
        #close-analysis-btn { padding: 10px 20px; background-color: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer; align-self: center; margin-top: 10px; }
        #close-analysis-btn:hover { background-color: #5a6268; }
        .modal-disclaimer { font-size: 0.75em; color: #777; text-align: center; margin-top: 15px; border-top: 1px dashed #ddd; padding-top: 10px;}

    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="controls-panel">
        <h3>Simulador de Constelação</h3>
        <div class="control-group">
            <label for="exercise-select">Selecionar Exercício:</label>
            <select id="exercise-select">
                <option value="free">Exploração Livre</option>
            </select>
            <div id="exercise-info">Selecione um exercício acima.</div>
            <button id="start-exercise-btn" class="action-btn" disabled>Iniciar Exercício</button>
        </div>
        <hr>
        <div class="control-group">
            <label for="rep-label">Rótulo do Novo Representante:</label>
            <input type="text" id="rep-label" value="Novo">
            <button id="add-rep-btn">Adicionar Representante</button>
        </div>
        <hr>

        <div id="selected-controls" style="display: none;">
            <h4>Representante: <span id="selected-name"></span></h4>
              <div class="control-group">
                <label for="edit-label">Editar Rótulo:</label>
                <input type="text" id="edit-label">
                <label class="inline-label" for="edit-color">Cor:</label>
                <input type="color" id="edit-color">
                <button id="update-rep-btn">Atualizar Rep.</button>
              </div>
             <div class="control-group">
                  <label for="edit-size" class="size-control-label">Tamanho Rep.:</label>
                  <input type="range" id="edit-size" min="0.5" max="2.5" step="0.1" value="1">
                  <span id="size-value" class="value-display">1.0x</span>
             </div>
             <div class="control-group">
                <label>Girar Rep. (Mouse + Shift):</label>
                <p style="font-size: 0.8em; color: #555; margin: 2px 0;">Clique e arraste no representante com Shift.</p>
            </div>
             <div class="control-group">
                  <label>Mover Câmera (Teclas):</label>
                  <p style="font-size: 0.8em; color: #555; margin: 2px 0;">Use W, S, A, D.</p>
             </div>
            <div class="control-group">
                <button id="remove-rep-btn" class="remove-btn">Remover Representante</button>
            </div>
              <div id="selected-info">
                </div>

            <div id="indicator-controls">
                <h4>Indicadores de Direção/Ação</h4>
                <div class="control-group">
                    <button id="add-arrow-indicator-btn" class="secondary-action-btn">Add Seta</button>
                    <button id="add-field-indicator-btn" class="secondary-action-btn">Add Campo</button>
                </div>
                <div class="control-group">
                     <label for="indicator-select">Selecionar Indicador:</label>
                     <select id="indicator-select">
                         <option value="">-- Nenhum --</option>
                         </select>
                </div>

                <div id="indicator-specific-controls">
                    <div class="control-group">
                        <label for="indicator-rotate">Rotação Indicador:</label>
                        <input type="range" id="indicator-rotate" min="-180" max="180" step="5" value="0">
                        <span id="indicator-rotate-value" class="value-display">0°</span>
                    </div>
                    <div class="control-group">
                        <label for="indicator-range">Alcance/Intensidade:</label>
                        <input type="range" id="indicator-range" min="0.5" max="10" step="0.1" value="1">
                        <span id="indicator-range-value" class="value-display">1.0x</span>
                    </div>
                     <div class="control-group">
                         <button id="remove-indicator-btn" class="remove-btn">Remover Indicador Sel.</button>
                     </div>
                     <div id="indicator-info">
                         </div>
                </div>
            </div>
            <hr style="margin-top: 20px;">
        </div>

        <div class="disclaimer">
            <strong>Aviso:</strong> Este é um simulador para fins educativos e de exploração pessoal. Não substitui terapia ou acompanhamento profissional qualificado. As interpretações são baseadas em padrões espaciais gerais e podem variar muito.
        </div>
    </div>

    <div id="guidance-panel">
        <h4 id="guidance-title">Guia do Exercício</h4>
        <div id="guidance-content"><p>Siga as instruções passo a passo.</p></div>
        <div id="guidance-navigation">
            <button id="prev-step-btn" disabled>Anterior</button>
            <span id="step-counter">Passo 1 / X</span>
            <button id="next-step-btn">Próximo</button>
        </div>
         <button id="end-exercise-btn" class="action-btn remove-btn" style="margin-top: 15px;">Finalizar Exercício</button>
    </div>

    <div id="analysis-modal">
        <h4>Análise da Disposição (Exploratória)</h4>
        <div id="analysis-content"></div>
        <div class="modal-disclaimer">
            Lembre-se: Esta análise é baseada em padrões espaciais e não substitui a percepção e o trabalho com um profissional.
        </div>
        <button id="close-analysis-btn">Fechar Análise</button>
    </div>
	
	<script type="module">
        // --- Importações ---
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Constantes ---
        const MOVE_SPEED = 0.2; // Speed for WSAD movement
        const INDICATOR_ARROW_COLOR = 0x3333cc; // Azul escuro para setas
        const INDICATOR_FIELD_COLOR = 0xcc3333; // Vermelho para campos
        const INDICATOR_BASE_RANGE_ARROW = 3.0; // Comprimento base da seta (escala 1x)
        const INDICATOR_BASE_RANGE_FIELD = 4.0; // Raio/Altura base do campo (escala 1x)

        // --- Variáveis Globais ---
        let scene, camera, renderer, controls;
        let groundPlane, gridHelper;
        let representatives = [];
        let selectedRepresentative = null;
        let selectedIndicatorId = null; // <<< ID do indicador selecionado no painel
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isDragging = false;
        let isRotating = false;
        let dragOffset = new THREE.Vector3();
        let planeIntersect = new THREE.Vector3();
        let initialRotationAngle = 0;
        let shiftKeyPressed = false;
        let clock = new THREE.Clock();

        // --- Estado do Exercício ---
        let currentExercise = null;
        let currentStepIndex = 0;
        let inExerciseMode = false;
        let timelineMarkers = {};

        // --- Estado de Movimento WSAD ---
        const moveState = { forward: false, backward: false, left: false, right: false };

        // --- Elementos DOM ---
        const canvasContainer = document.getElementById('canvas-container');
        const controlsPanel = document.getElementById('controls-panel');
        const addRepBtn = document.getElementById('add-rep-btn');
        const repLabelInput = document.getElementById('rep-label');
        const selectedControlsDiv = document.getElementById('selected-controls');
        const selectedNameSpan = document.getElementById('selected-name');
        const editLabelInput = document.getElementById('edit-label');
        const editColorInput = document.getElementById('edit-color');
        const updateRepBtn = document.getElementById('update-rep-btn');
        const removeRepBtn = document.getElementById('remove-rep-btn');
        const selectedPosSpan = document.getElementById('selected-pos');
        const selectedDirSpan = document.getElementById('selected-dir');
        const proximityInfoDiv = document.getElementById('proximity-info');
        const reflectionPromptDiv = document.getElementById('reflection-prompt');
        const editSizeSlider = document.getElementById('edit-size');
        const sizeValueSpan = document.getElementById('size-value');
        // Novos DOM elements para indicadores
        const addArrowIndicatorBtn = document.getElementById('add-arrow-indicator-btn');
        const addFieldIndicatorBtn = document.getElementById('add-field-indicator-btn');
        const indicatorSelect = document.getElementById('indicator-select');
        const indicatorSpecificControlsDiv = document.getElementById('indicator-specific-controls');
        const indicatorRotateSlider = document.getElementById('indicator-rotate');
        const indicatorRotateValueSpan = document.getElementById('indicator-rotate-value');
        const indicatorRangeSlider = document.getElementById('indicator-range');
        const indicatorRangeValueSpan = document.getElementById('indicator-range-value');
        const removeIndicatorBtn = document.getElementById('remove-indicator-btn');
        const indicatorInfoDiv = document.getElementById('indicator-info');
        // Exercício e Análise (sem mudanças nos IDs)
        const exerciseSelect = document.getElementById('exercise-select');
        const exerciseInfoDiv = document.getElementById('exercise-info');
        const startExerciseBtn = document.getElementById('start-exercise-btn');
        const guidancePanel = document.getElementById('guidance-panel');
        const guidanceTitle = document.getElementById('guidance-title');
        const guidanceContent = document.getElementById('guidance-content');
        const prevStepBtn = document.getElementById('prev-step-btn');
        const nextStepBtn = document.getElementById('next-step-btn');
        const stepCounterSpan = document.getElementById('step-counter');
        const endExerciseBtn = document.getElementById('end-exercise-btn');
        const analysisModal = document.getElementById('analysis-modal');
        const analysisContent = document.getElementById('analysis-content');
        const closeAnalysisBtn = document.getElementById('close-analysis-btn');


        // --- Definição dos Exercícios (Inalterado) ---
        const exercises = {
            'lugar': { name: "Ocupar o Próprio Lugar", reps: "~3-5", description: "Explorar seu lugar no sistema e possíveis emaranhamentos.", steps: ["Adicione um representante para 'Você'. Posicione-o no campo.", "Adicione representantes para figuras familiares chave (ex: 'Pai', 'Mãe', talvez um 'Padrão Repetitivo' ou 'Destino Difícil' de um ancestral com quem se identifica).", "Posicione esses representantes em relação a 'Você', como sentir que eles estão internamente.", "Observe as distâncias, direções e a sensação geral. Quem está perto? Quem está longe? Quem olha para quem?", "Reflita (usando o painel de info): Você está no seu lugar de filho(a)? Está assumindo responsabilidades que não são suas? Está olhando para seu próprio caminho?", "Experimente mover 'Você' para um lugar que sinta mais força e pertencimento. Observe como as relações mudam.", "Agradeça aos representantes. Quando estiver satisfeito(a) com a disposição final, clique em 'Analisar Disposição'."]},
            'espelho': { name: "Meta Espelho de Relacionamentos", reps: "3-5", description: "Explorar a dinâmica de relacionamentos específicos.", steps: ["Escolha 1 ou 2 relacionamentos para explorar (ex: com parceiro(a), amigo(a), familiar).", "Adicione um representante para 'Você'.", "Adicione um representante para a 'Pessoa 1' (do relacionamento escolhido).", "Se escolheu um segundo relacionamento, adicione 'Pessoa 2'.", "Posicione os representantes no campo de acordo com como você percebe a din\u00E2mica atual entre vocês.", "Observe as posições. Quem está mais perto/longe? Quem olha para quem? Qual a sensação?", "**Passo da Empatia (Mental):** Imagine-se no lugar da 'Pessoa 1'. Como ela vê 'Você'? O que ela sente na relação? (Use a visualização para apoiar essa reflexão).", "**Passo Neutro (Mental):** Imagine-se olhando para 'Você' e 'Pessoa 1' de fora. O que você percebe sobre a dinâmica que não via antes?", "Reflita: O que você gostaria que mudasse? Quais posturas suas poderiam facilitar isso?", "Se adicionou 'Pessoa 2', repita os passos de observação e empatia para essa relação.", "Agradeça aos representantes. Quando a disposição final estiver clara, clique em 'Analisar Disposição'."]},
            'ordem': { name: "Ordem Hierárquica", reps: "~3-6", description: "Refletir sobre a ordem hierárquica na família.", steps: ["Adicione representantes para 'Você', 'Pai' e 'Mãe'.", "Se tiver irmãos, adicione representantes para eles ('Irmão Mais Velho', 'Irmã Mais Nova', etc.).", "Posicione 'Pai' e 'Mãe' lado a lado ou como sentir que representa a relação deles.", "Posicione 'Você' e seus irmãos (se houver) na ordem de nascimento, geralmente um pouco à frente dos pais.", "Observe a configuração. Você está no seu lugar correto de acordo com a ordem de chegada (nascimento)?", "Reflita (usando o painel de info): Você se sente 'maior' ou 'menor' que seus pais ou irmãos mais velhos?", "Você assume responsabilidades que seriam dos seus pais ou irmãos mais velhos?", "Experimente mover 'Você' para o lugar que corresponde à sua ordem de nascimento. Como se sente?", "Agradeça aos representantes. Quando a imagem final estiver definida, clique em 'Analisar Disposição'."]},
            'timeline': { name: "Linha do Tempo Sistêmica", reps: "~5+", description: "Visualizar eventos marcantes da vida em uma linha do tempo espacial.", steps: ["Este exercício usa o eixo Z (profundidade) para representar o tempo.", "Adicione um representante para 'Nascimento' e posicione-o em uma extremidade do campo (ex: Z = -30).", "Adicione um representante para 'Futuro/Morte' e posicione-o na extremidade oposta (ex: Z = 30).", "Adicione um representante para 'Momento Presente' e posicione-o entre 'Nascimento' e 'Futuro', onde sentir que ele se encontra.", "Agora, adicione representantes para 'Eventos Marcantes Positivos' da sua vida. Posicione-os espacialmente ao longo do 'caminho' entre 'Nascimento' e 'Presente'. Use a posição X ou Y (altura) para diferenciá-los se desejar.", "Adicione representantes para 'Eventos Marcantes Negativos/Desafiadores'. Posicione-os também ao longo do caminho.", "Observe a distribuição espacial desses eventos. Há concentrações? Lacunas? Como você se sente olhando para essa representação da sua jornada?", "Reflita sobre como os eventos negativos podem ter gerado forças ou aprendizados (representados pelos positivos próximos ou posteriores).", "Olhe para o espaço entre 'Presente' e 'Futuro'. Quais 'Eventos Desejados' você adicionaria nesse espaço? Posicione-os.", "Reflita: Quais padrões ou crenças (talvez representados pelos eventos negativos) precisam ser vistos ou transformados para alcançar os 'Eventos Desejados'?", "Agradeça a todos os eventos e representantes. Quando a linha do tempo estiver completa, clique em 'Analisar Disposição'."]},
            'beliefs': { name: "Avaliação de Crenças Sistêmicas", reps: "~5-13+", description: "Explorar a relação entre suas crenças e as crenças parentais.", steps: ["Adicione representantes para 'Você', 'Pai' e 'Mãe'. Posicione-os.", "Escolha um aspecto da vida para começar (ex: 'Felicidade'). Adicione um representante para ele.", "Adicione um representante para 'Crença dos Pais sobre [Aspecto]' (ex: 'Crença Pais - Felicidade'). Posicione-o em relação a 'Pai', 'Mãe' e 'Felicidade', como você percebe a crença deles.", "Adicione um representante para 'Minha Crença sobre [Aspecto]' (ex: 'Minha Crença - Felicidade'). Posicione-o em relação a 'Você', 'Felicidade' e 'Crença dos Pais'.", "Observe as posições e direções. 'Minha Crença' está alinhada com a dos pais? Está olhando para eles, para 'Você' ou para o aspecto ('Felicidade')?", "Reflita: Como você se sente em relação a essa configuração? Qual a origem da 'Minha Crença'?", "Repita os passos 2 a 6 para outros aspectos importantes: 'Amor', 'Sexo', 'Dinheiro', 'Sucesso', 'Deus'. Use o mesmo representante para 'Pai' e 'Mãe', mas crie novos para cada aspecto e crença associada.", "Após explorar os aspectos, reflita: Quais 'Crenças a Eliminar' você identificou? Adicione representantes para elas e veja onde se posicionam.", "Quais 'Crenças a Adicionar' (ou fortalecer) você deseja? Adicione representantes e posicione-os. Eles olham para onde?", "Observe a imagem final. Como a introdução das crenças a eliminar/adicionar muda a dinâmica?", "Agradeça aos representantes. Quando a exploração das crenças estiver completa, clique em 'Analisar Disposição'."]}
        };

        // --- Inicialização ---
        function init() {
            // Configuração da Cena, Câmera, Luzes, Renderer, Controles, Chão, Grid
            scene = new THREE.Scene(); scene.background = new THREE.Color(0xeeeeee);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.set(0, 15, 25); camera.lookAt(0, 0, 0);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(10, 20, 15); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 1024; directionalLight.shadow.mapSize.height = 1024; scene.add(directionalLight);
            renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; canvasContainer.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.1; controls.screenSpacePanning = true; controls.minDistance = 5; controls.maxDistance = 80; controls.maxPolarAngle = Math.PI / 2 - 0.05;
            const groundGeometry = new THREE.PlaneGeometry(100, 100); const groundMaterial = new THREE.MeshStandardMaterial({ color: 0xd8e2dc, roughness: 0.8, metalness: 0.2, side: THREE.DoubleSide }); groundPlane = new THREE.Mesh(groundGeometry, groundMaterial); groundPlane.rotation.x = -Math.PI / 2; groundPlane.receiveShadow = true; groundPlane.name = "GroundPlane"; scene.add(groundPlane);
            gridHelper = new THREE.GridHelper(100, 100, 0xcccccc, 0xdddddd); gridHelper.position.y = 0.01; scene.add(gridHelper);

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            canvasContainer.addEventListener('mousemove', onMouseMove);
            canvasContainer.addEventListener('mousedown', onMouseDown);
            canvasContainer.addEventListener('mouseup', onMouseUp);
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            // Representante
            addRepBtn.addEventListener('click', addRepresentative);
            updateRepBtn.addEventListener('click', updateSelectedRepresentative);
            removeRepBtn.addEventListener('click', removeSelectedRepresentative);
            editSizeSlider.addEventListener('input', updateSelectedSize);
            // Indicadores
            addArrowIndicatorBtn.addEventListener('click', () => addIndicator(selectedRepresentative, 'arrow'));
            addFieldIndicatorBtn.addEventListener('click', () => addIndicator(selectedRepresentative, 'field'));
            indicatorSelect.addEventListener('change', handleIndicatorSelectionChange);
            indicatorRotateSlider.addEventListener('input', handleIndicatorRotateChange);
            indicatorRangeSlider.addEventListener('input', handleIndicatorRangeChange);
            removeIndicatorBtn.addEventListener('click', removeSelectedIndicator);
            // Exercício / Análise
            exerciseSelect.addEventListener('change', updateExerciseInfo);
            startExerciseBtn.addEventListener('click', startExercise);
            prevStepBtn.addEventListener('click', prevGuidanceStep);
            nextStepBtn.addEventListener('click', handleNextStepOrAnalyze);
            endExerciseBtn.addEventListener('click', endExercise);
            closeAnalysisBtn.addEventListener('click', closeAnalysisModal);

            // Preencher Select e Iniciar
            populateExerciseSelect();
            updateExerciseInfo();
            animate();
        }
		
		// --- Funções de Criação/Manipulação de Representantes ---

        /**
         * Creates a board game pawn-like representative mesh.
         * Initializes userData with an empty indicators array.
         */
        function createPawnRepresentative(label = "Rep", position = new THREE.Vector3(0, 0, 0), color = Math.random() * 0xffffff) {
            const group = new THREE.Group();

            // Define Pawn Dimensions (local to this function)
            const PAWN_BASE_RADIUS = 0.4;
            const PAWN_BASE_HEIGHT = 0.2;
            const PAWN_BODY_TOP_RADIUS = 0.15;
            const PAWN_BODY_HEIGHT = 0.7;
            const PAWN_HEAD_RADIUS = 0.20;

            // Calculate Y Offset based on this pawn's base height
            const PAWN_BASE_OFFSET_Y = PAWN_BASE_HEIGHT / 2;
            group.position.copy(position);
            group.position.y = PAWN_BASE_OFFSET_Y;

            // Material
            const pawnMaterial = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.6,
                metalness: 0.1
            });

            // Base (Cylinder)
            const baseGeometry = new THREE.CylinderGeometry(PAWN_BASE_RADIUS, PAWN_BASE_RADIUS, PAWN_BASE_HEIGHT, 24);
            const baseMesh = new THREE.Mesh(baseGeometry, pawnMaterial);
            baseMesh.position.y = 0; // Relative to group's origin
            baseMesh.castShadow = true; baseMesh.receiveShadow = true; baseMesh.name = "PawnBase";
            group.add(baseMesh);

            // Body (Tapered Cylinder)
            const bodyGeometry = new THREE.CylinderGeometry(PAWN_BODY_TOP_RADIUS, PAWN_BASE_RADIUS, PAWN_BODY_HEIGHT, 24);
            const bodyMesh = new THREE.Mesh(bodyGeometry, pawnMaterial);
            bodyMesh.position.y = (PAWN_BASE_HEIGHT / 2) + (PAWN_BODY_HEIGHT / 2); // Relative
            bodyMesh.castShadow = true; bodyMesh.receiveShadow = true; bodyMesh.name = "PawnBody";
            group.add(bodyMesh);

            // Head (Sphere)
            const headGeometry = new THREE.SphereGeometry(PAWN_HEAD_RADIUS, 16, 12);
            const headMesh = new THREE.Mesh(headGeometry, pawnMaterial);
            headMesh.position.y = (PAWN_BASE_HEIGHT / 2) + PAWN_BODY_HEIGHT + PAWN_HEAD_RADIUS; // Relative
            headMesh.castShadow = true; headMesh.receiveShadow = true; headMesh.name = "PawnHead";
            group.add(headMesh);

            // User Data - CRITICAL: Initialize indicators array
            group.userData = {
                id: THREE.MathUtils.generateUUID(),
                label: label,
                color: color,
                baseOffsetY: PAWN_BASE_OFFSET_Y,
                type: "Representative",
                currentScale: 1.0,
                indicators: [] // <<<<< ARRAY PARA GUARDAR OS INDICADORES
            };
            group.name = `Representative_${label}`;

            scene.add(group);
            representatives.push(group);
            return group;
        }

        function addRepresentative() {
            const label = repLabelInput.value.trim() || "Novo";
            const x = (Math.random() - 0.5) * 10;
            const z = (Math.random() - 0.5) * 10;
            const colorValue = Math.random() * 0xffffff;
            createPawnRepresentative(label, new THREE.Vector3(x, 0, z), colorValue);
            repLabelInput.value = "Novo"; // Reset input
        }

        function selectRepresentative(representative) {
            if (selectedRepresentative === representative) return;

            // Reset previous selection highlight
            if (selectedRepresentative) {
                selectedRepresentative.traverse((child) => {
                    if (child.isMesh && child.material && child.material.emissive) {
                        child.material.emissive.setHex(0x000000);
                    }
                });
                 // Hide indicator controls when deselecting rep
                 indicatorSpecificControlsDiv.style.display = 'none';
                 indicatorSelect.innerHTML = '<option value="">-- Nenhum --</option>'; // Clear dropdown
                 selectedIndicatorId = null;
            }

            selectedRepresentative = representative;

            if (representative) {
                // Update Rep Info
                selectedNameSpan.textContent = representative.userData.label;
                editLabelInput.value = representative.userData.label;
                const currentScale = representative.userData.currentScale || 1.0;
                editSizeSlider.value = currentScale;
                sizeValueSpan.textContent = `${currentScale.toFixed(1)}x`;

                // Apply highlight and set color picker
                let foundColor = null;
                representative.traverse((child) => {
                    if (child.isMesh && child.material) { // Check all meshes
                         if(child.name !== 'IndicatorArrowMesh' && child.name !== 'IndicatorFieldMesh' && child.name !== 'DirectionArrow' ) { // Don't highlight indicators this way
                            if (child.material.emissive) {
                                child.material.emissive.setHex(0x555555); // Highlight main body
                            }
                            if (!foundColor && child.material.color) { // Get color from first main part
                                foundColor = "#" + child.material.color.getHexString();
                            }
                         }
                    }
                });
                editColorInput.value = foundColor || ("#" + new THREE.Color(representative.userData.color).getHexString());

                // Populate Indicator Dropdown
                populateIndicatorSelect(representative);
                // Reset and hide indicator controls until one is selected from dropdown
                indicatorSpecificControlsDiv.style.display = 'none';
                selectedIndicatorId = null;


                selectedControlsDiv.style.display = 'block'; // Show main rep controls
                updateSelectedInfo(); // Update text info for rep

            } else {
                // No representative selected
                selectedControlsDiv.style.display = 'none';
                editColorInput.value = '#ffffff';
                indicatorSelect.innerHTML = '<option value="">-- Nenhum --</option>';
                indicatorSpecificControlsDiv.style.display = 'none';
                selectedIndicatorId = null;
            }
        }
		
		// --- Funções de Gerenciamento de Indicadores ---

        /** Cria um objeto 3D para um indicador (seta ou campo) */
        function createIndicatorObject(type, id) {
            let indicatorObject;
            const indicatorGroup = new THREE.Group(); // Group to hold mesh + allow easy rotation/scaling
            indicatorGroup.name = `IndicatorGroup_${type}_${id}`;

            if (type === 'arrow') {
                const arrowHeight = INDICATOR_BASE_RANGE_ARROW; // Use base range as initial length
                const arrowRadius = arrowHeight * 0.1; // Proportional radius
                const arrowGeometry = new THREE.ConeGeometry(arrowRadius, arrowHeight, 8);
                // Point geometry along -Z for easier scaling later
                arrowGeometry.translate(0, -arrowHeight / 2, 0); // Center base at origin
                arrowGeometry.rotateX(Math.PI / 2); // Rotate to point along -Z

                const arrowMaterial = new THREE.MeshStandardMaterial({
                    color: INDICATOR_ARROW_COLOR,
                    roughness: 0.7,
                    metalness: 0.1
                });
                const arrowMesh = new THREE.Mesh(arrowGeometry, arrowMaterial);
                arrowMesh.name = `IndicatorArrowMesh_${id}`;
                arrowMesh.castShadow = true;
                indicatorGroup.add(arrowMesh); // Add mesh to the group
                indicatorObject = indicatorGroup;

            } else if (type === 'field') {
                const fieldRadius = INDICATOR_BASE_RANGE_FIELD * 0.5; // Base radius proportional to range
                const fieldHeight = INDICATOR_BASE_RANGE_FIELD; // Base range/height
                const fieldGeometry = new THREE.ConeGeometry(fieldRadius, fieldHeight, 16, 1, true); // Open ended cone
                 // Point geometry along -Z
                fieldGeometry.translate(0, -fieldHeight / 2, 0); // Center base at origin
                fieldGeometry.rotateX(Math.PI / 2);

                const fieldMaterial = new THREE.MeshStandardMaterial({
                    color: INDICATOR_FIELD_COLOR,
                    roughness: 0.8,
                    metalness: 0.0,
                    transparent: true,
                    opacity: 0.35,
                    side: THREE.DoubleSide // Render inside and outside
                });
                const fieldMesh = new THREE.Mesh(fieldGeometry, fieldMaterial);
                fieldMesh.name = `IndicatorFieldMesh_${id}`;
                // fieldMesh.castShadow = true; // Usually don't cast shadow from transparent fields
                indicatorGroup.add(fieldMesh);
                indicatorObject = indicatorGroup;
            }

            if (indicatorObject) {
                 // Initial position slightly above pawn base, adjust as needed
                 indicatorObject.position.y = 0.2; // Relative Y position within the Representative Group
            }
            return indicatorObject; // Return the GROUP
        }

        /** Adiciona um indicador (seta ou campo) a um representante */
        function addIndicator(representative, type) {
            if (!representative) return;

            const id = THREE.MathUtils.generateUUID();
            const indicatorObject3D = createIndicatorObject(type, id);

            if (!indicatorObject3D) return; // Failed to create object

            const indicatorData = {
                id: id,
                type: type,
                rotationY: 0, // Initial rotation relative to pawn
                rangeScale: 1.0, // Initial scale/intensity
                object3D: indicatorObject3D // Reference to the THREE.Group
            };

            // Add data to representative's userData
            representative.userData.indicators.push(indicatorData);
            // Add 3D object as a child of the representative's main group
            representative.add(indicatorObject3D);

            // Update UI
            populateIndicatorSelect(representative);
            // Select the newly added indicator
            indicatorSelect.value = id;
            handleIndicatorSelectionChange(); // Trigger UI update for the new selection
        }

        /** Remove o indicador selecionado atualmente */
        function removeSelectedIndicator() {
            if (!selectedRepresentative || !selectedIndicatorId) return;

            const repData = selectedRepresentative.userData;
            const indicatorIndex = repData.indicators.findIndex(ind => ind.id === selectedIndicatorId);

            if (indicatorIndex > -1) {
                const indicatorToRemove = repData.indicators[indicatorIndex];
                // Remove 3D object from scene graph
                if (indicatorToRemove.object3D) {
                    selectedRepresentative.remove(indicatorToRemove.object3D);
                    // TODO: Dispose geometry/material if needed
                }
                // Remove data from array
                repData.indicators.splice(indicatorIndex, 1);

                // Update UI
                populateIndicatorSelect(selectedRepresentative); // Repopulate dropdown
                indicatorSpecificControlsDiv.style.display = 'none'; // Hide controls
                selectedIndicatorId = null; // Clear selection
                indicatorInfoDiv.innerHTML = ""; // Clear info text
            }
        }

         /** Atualiza a rotação do indicador selecionado */
         function handleIndicatorRotateChange() {
             if (!selectedRepresentative || !selectedIndicatorId) return;
             const indicator = selectedRepresentative.userData.indicators.find(ind => ind.id === selectedIndicatorId);
             if (!indicator || !indicator.object3D) return;

             const degrees = parseFloat(indicatorRotateSlider.value);
             const radians = THREE.MathUtils.degToRad(degrees);

             indicator.rotationY = radians; // Store radians in data
             indicator.object3D.rotation.y = radians; // Apply rotation to the 3D object (Group)

             indicatorRotateValueSpan.textContent = `${degrees.toFixed(0)}°`; // Update UI display
             updateSelectedInfo(); // Update main info panel too
         }

         /** Atualiza o alcance/intensidade (escala) do indicador selecionado */
         function handleIndicatorRangeChange() {
              if (!selectedRepresentative || !selectedIndicatorId) return;
              const indicator = selectedRepresentative.userData.indicators.find(ind => ind.id === selectedIndicatorId);
              if (!indicator || !indicator.object3D) return;

              const scale = parseFloat(indicatorRangeSlider.value);
              indicator.rangeScale = scale; // Store scale in data

              // Scale along the Z axis (assuming indicator points along -Z)
              // For Cone (field), scale affects height and radius if not adjusted
              // We scale the Indicator Group
              indicator.object3D.scale.z = scale;
              // For field type, maybe scale X too to keep aspect ratio?
               if (indicator.type === 'field') {
                    indicator.object3D.scale.x = scale; // Scale radius along with height
                    // Y scale should remain 1 unless you want vertical stretch
               } else {
                    indicator.object3D.scale.x = 1; // Reset X scale for arrow
               }
               indicator.object3D.scale.y = 1; // Keep Y scale 1


              indicatorRangeValueSpan.textContent = `${scale.toFixed(1)}x`; // Update UI display
              updateSelectedInfo(); // Update main info panel too
         }

        /** Popula o dropdown de indicadores e atualiza controles */
        function populateIndicatorSelect(representative) {
            if (!representative) {
                indicatorSelect.innerHTML = '<option value="">-- Nenhum --</option>';
                return;
            }

            const indicators = representative.userData.indicators || [];
            // Preserve current selection if possible
            const currentSelectedValue = selectedIndicatorId;

            indicatorSelect.innerHTML = '<option value="">-- Selecione --</option>'; // Default option

            indicators.forEach((indicator, index) => {
                const option = document.createElement('option');
                option.value = indicator.id;
                option.textContent = `${indicator.type.charAt(0).toUpperCase() + indicator.type.slice(1)} ${index + 1}`; // e.g., "Arrow 1", "Field 2"
                indicatorSelect.appendChild(option);
            });

            // Try to reselect the previously selected indicator
            if (currentSelectedValue && indicators.some(ind => ind.id === currentSelectedValue)) {
                 indicatorSelect.value = currentSelectedValue;
            } else {
                 indicatorSelect.value = ""; // No selection or previous selection gone
                 indicatorSpecificControlsDiv.style.display = 'none';
                 selectedIndicatorId = null;
            }
        }

        /** Lida com a mudança de seleção no dropdown de indicadores */
        function handleIndicatorSelectionChange() {
            selectedIndicatorId = indicatorSelect.value;

            if (!selectedRepresentative || !selectedIndicatorId) {
                indicatorSpecificControlsDiv.style.display = 'none';
                indicatorInfoDiv.innerHTML = "";
                return;
            }

            const indicator = selectedRepresentative.userData.indicators.find(ind => ind.id === selectedIndicatorId);
            if (indicator) {
                // Update UI controls with the selected indicator's values
                const degrees = THREE.MathUtils.radToDeg(indicator.rotationY || 0);
                indicatorRotateSlider.value = degrees;
                indicatorRotateValueSpan.textContent = `${degrees.toFixed(0)}°`;

                const scale = indicator.rangeScale || 1.0;
                indicatorRangeSlider.value = scale;
                indicatorRangeValueSpan.textContent = `${scale.toFixed(1)}x`;

                indicatorSpecificControlsDiv.style.display = 'block'; // Show controls
                updateSelectedInfo(); // Update text info display
            } else {
                indicatorSpecificControlsDiv.style.display = 'none'; // Hide if somehow not found
                indicatorInfoDiv.innerHTML = "";
            }
        }


        // --- Funções de Atualização/Remoção de Representante (Adaptadas) ---

        function updateSelectedRepresentative() {
            // (Código inalterado da Parte 3)
             if (!selectedRepresentative) return;
             const newLabel = editLabelInput.value.trim() || selectedRepresentative.userData.label;
             selectedRepresentative.userData.label = newLabel;
             selectedRepresentative.name = `Representative_${newLabel}`;
             selectedNameSpan.textContent = newLabel;
             const newColorHex = editColorInput.value;
             const newColor = new THREE.Color(newColorHex);
             selectedRepresentative.userData.color = newColor.getHex();
             selectedRepresentative.traverse((child) => {
                 if (child.isMesh && child.material && child.name !== 'IndicatorArrowMesh' && child.name !== 'IndicatorFieldMesh' && child.name !== 'DirectionArrow') {
                    child.material.color.set(newColor);
                 }
             });
             updateSelectedInfo();
        }

        function updateSelectedSize() {
            // (Código inalterado da Parte 3 - já usa userData.baseOffsetY)
            if (!selectedRepresentative) return;
            const newScale = parseFloat(editSizeSlider.value);
            sizeValueSpan.textContent = `${newScale.toFixed(1)}x`;
            selectedRepresentative.scale.set(newScale, newScale, newScale);
            selectedRepresentative.userData.currentScale = newScale;
            const baseOffsetY = selectedRepresentative.userData.baseOffsetY;
             if (typeof baseOffsetY === 'number') {
                 selectedRepresentative.position.y = baseOffsetY * newScale;
             } else {
                 console.warn("userData.baseOffsetY não encontrado para", selectedRepresentative.userData.label);
                 selectedRepresentative.position.y = (0.1) * newScale; // Fallback
             }
            updateSelectedInfo();
        }

        function removeSelectedRepresentative() {
            // (Código inalterado da Parte 3)
            if (!selectedRepresentative) return;
             const index = representatives.indexOf(selectedRepresentative);
             if (index > -1) {
                 representatives.splice(index, 1);
             }
             scene.remove(selectedRepresentative);
             selectRepresentative(null);
        }

        function removeAllRepresentatives() {
            // (Código inalterado da Parte 3)
            const repsToRemove = [...representatives];
             repsToRemove.forEach(rep => {
                 const index = representatives.indexOf(rep);
                 if (index > -1) {
                     representatives.splice(index, 1);
                 }
                 scene.remove(rep);
             });
             selectRepresentative(null);
             timelineMarkers = {};
        }
		
		// --- Lógica de Interação (Raycasting, Drag, Rotate - Inalterado em sua maior parte) ---

        function updateMouseCoords(event) {
             // (Código inalterado da Parte 3)
            const rect = canvasContainer.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function getIntersectedObject(event) {
            // (Código inalterado da Parte 3 - AINDA SÓ PEGA REPRESENTANTES, não indicadores)
            // Para clicar em indicadores, esta função precisaria ser mais complexa
            updateMouseCoords(event);
            raycaster.setFromCamera(mouse, camera);
            const potentialTargets = [];
            representatives.forEach(rep => {
                rep.traverse((child) => {
                    // Apenas meshes do corpo principal para seleção do representante
                    if (child.isMesh && (child.name.startsWith("Pawn") || child.name === "RepresentativeBody")) {
                        potentialTargets.push(child);
                    }
                });
            });
            const intersects = raycaster.intersectObjects(potentialTargets, false);
            if (intersects.length > 0) {
                let intersectedObject = intersects[0].object;
                while (intersectedObject.parent && !representatives.includes(intersectedObject)) {
                    intersectedObject = intersectedObject.parent;
                }
                if (representatives.includes(intersectedObject)) {
                    return intersectedObject;
                }
            }
            return null;
        }

        function getGroundIntersection(event) {
            // (Código inalterado da Parte 3)
            updateMouseCoords(event);
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(groundPlane);
            if (intersects.length > 0) { return intersects[0].point; }
            return null;
        }

        function onMouseDown(event) {
            // (Código inalterado da Parte 3)
            if (event.button !== 0) return;
            const intersectedRep = getIntersectedObject(event);
             if (shiftKeyPressed && intersectedRep && intersectedRep === selectedRepresentative) {
                 isRotating = true; controls.enabled = false;
                 const repPosScreen = selectedRepresentative.position.clone().project(camera);
                 initialRotationAngle = Math.atan2(mouse.y - repPosScreen.y, mouse.x - repPosScreen.x) - selectedRepresentative.rotation.y;
                 canvasContainer.style.cursor = 'crosshair';
             } else if (intersectedRep) {
                 if (selectedRepresentative !== intersectedRep) { selectRepresentative(intersectedRep); }
                 isDragging = true; controls.enabled = false;
                 const intersectionPoint = getGroundIntersection(event);
                 if (intersectionPoint) { dragOffset.copy(intersectionPoint).sub(selectedRepresentative.position); }
                 else { dragOffset.set(0, 0, 0); }
                 canvasContainer.style.cursor = 'grabbing';
             } else {
                 selectRepresentative(null); isDragging = false; isRotating = false;
             }
        }

        function onMouseMove(event) {
             // (Código inalterado da Parte 3 - já usa userData.baseOffsetY no drag)
            updateMouseCoords(event);
             if (isRotating && selectedRepresentative) {
                 const repPosScreen = selectedRepresentative.position.clone().project(camera);
                 const currentMouseAngle = Math.atan2(mouse.y - repPosScreen.y, mouse.x - repPosScreen.x);
                 let targetAngle = currentMouseAngle - initialRotationAngle;
                 selectedRepresentative.rotation.y = targetAngle;
                 updateSelectedInfo();
             } else if (isDragging && selectedRepresentative) {
                 const intersectionPoint = getGroundIntersection(event);
                 if (intersectionPoint) {
                     selectedRepresentative.position.x = intersectionPoint.x - dragOffset.x;
                     selectedRepresentative.position.z = intersectionPoint.z - dragOffset.z;
                     const currentScale = selectedRepresentative.userData.currentScale || 1.0;
                     const baseOffsetY = selectedRepresentative.userData.baseOffsetY;
                     if (typeof baseOffsetY === 'number') {
                        selectedRepresentative.position.y = baseOffsetY * currentScale;
                    } else {
                        console.warn("userData.baseOffsetY não encontrado para", selectedRepresentative.userData.label);
                        selectedRepresentative.position.y = (0.1) * currentScale; // Fallback
                    }
                     updateSelectedInfo();
                 }
             } else {
                 const intersectedRep = getIntersectedObject(event);
                 if (intersectedRep) { canvasContainer.style.cursor = 'pointer'; }
                 else if (shiftKeyPressed && selectedRepresentative) { canvasContainer.style.cursor = 'crosshair';}
                 else { canvasContainer.style.cursor = controls.enabled ? 'grab' : 'grabbing'; }
             }
        }

        function onMouseUp(event) {
             // (Código inalterado da Parte 3)
            if (event.button !== 0) return;
             if (isRotating) {
                 isRotating = false; controls.enabled = true;
                 updateSelectedInfo();
             } else if (isDragging) {
                 isDragging = false; controls.enabled = true;
                 updateSelectedInfo();
             }
             if (!isDragging && !isRotating) {
                 const intersectedRep = getIntersectedObject(event);
                 canvasContainer.style.cursor = intersectedRep ? 'pointer' : 'grab';
             }
        }

        function onKeyDown(event) {
            // (Código inalterado da Parte 3)
            if (event.key === 'Shift' && !shiftKeyPressed) {
                 shiftKeyPressed = true;
                 if (selectedRepresentative && !isDragging && !isRotating) {
                     canvasContainer.style.cursor = 'crosshair';
                 }
             }
             switch (event.key.toLowerCase()) {
                 case 'w': moveState.forward = true; break;
                 case 's': moveState.backward = true; break;
                 case 'a': moveState.left = true; break;
                 case 'd': moveState.right = true; break;
             }
        }

        function onKeyUp(event) {
             // (Código inalterado da Parte 3)
            if (event.key === 'Shift') {
                 shiftKeyPressed = false;
                 if (!isDragging && !isRotating) {
                     const intersectedRep = getIntersectedObject(event);
                     canvasContainer.style.cursor = intersectedRep ? 'pointer' : 'grab';
                 }
             }
             switch (event.key.toLowerCase()) {
                 case 'w': moveState.forward = false; break;
                 case 's': moveState.backward = false; break;
                 case 'a': moveState.left = false; break;
                 case 'd': moveState.right = false; break;
             }
        }

        // --- Função de Feedback (updateSelectedInfo ATUALIZADA) ---
        function updateSelectedInfo() {
            if (!selectedRepresentative) {
                selectedControlsDiv.style.display = 'none';
                return;
            }

            // --- Informações do Representante Principal ---
            const repData = selectedRepresentative.userData;
            const pos = selectedRepresentative.position;
            selectedPosSpan.textContent = `X: ${pos.x.toFixed(1)}, Z: ${pos.z.toFixed(1)}`;

            // Direção principal do corpo do peão
            const bodyForward = new THREE.Vector3(0, 0, -1).applyQuaternion(selectedRepresentative.quaternion).normalize();
            selectedDirSpan.textContent = `Corpo: (${bodyForward.x.toFixed(2)}, ${bodyForward.z.toFixed(2)})`;

            // Proximidade e Reflexão (baseado na posição do corpo)
            let proximityHtml = '<h4>Proximidade (Corpo):</h4>';
            let reflectionHtml = '<h4>Reflexão (Geral):</h4>';
            let closestRep = null;
            let minDist = Infinity;

            representatives.forEach(otherRep => {
                if (otherRep === selectedRepresentative) return;
                const dist = pos.distanceTo(otherRep.position);
                proximityHtml += `<p>- ${otherRep.userData.label}: ${dist.toFixed(1)} u.</p>`;
                if (dist < minDist) { minDist = dist; closestRep = otherRep;}
            });
            proximityInfoDiv.innerHTML = proximityHtml;

            const currentScale = repData.currentScale || 1.0;
            if (closestRep) {
                const closeThreshold = 2.0 * currentScale;
                const farThreshold = 15.0 * currentScale;
                if (minDist < closeThreshold) reflectionHtml += `<p>Próximo(a) de '${closestRep.userData.label}'. Como se sente?</p>`;
                else if (minDist > farThreshold) reflectionHtml += `<p>Distante de '${closestRep.userData.label}'. O que isso significa?</p>`;
            } else if (representatives.length > 1) {
                reflectionHtml += `<p>Isolado(a) no campo?</p>`;
            }
             reflectionHtml += `<p>Considere posição, tamanho, direção do corpo e dos indicadores.</p>`;
             reflectionPromptDiv.innerHTML = reflectionHtml;

            // --- Informações do Indicador Selecionado ---
            let indicatorText = "";
            if (selectedIndicatorId) {
                const indicator = repData.indicators.find(ind => ind.id === selectedIndicatorId);
                if (indicator && indicator.object3D) {
                     // Calcular direção MUNDIAL do indicador
                     const indicatorWorldQuaternion = new THREE.Quaternion();
                     indicator.object3D.getWorldQuaternion(indicatorWorldQuaternion); // Pega a rotação mundial do INDICADOR (que é filho do rep)

                     const indicatorForward = new THREE.Vector3(0, 0, -1); // Direção local do indicador (-Z)
                     indicatorForward.applyQuaternion(indicatorWorldQuaternion); // Aplica rotação mundial
                     indicatorForward.normalize();

                     const indicatorRange = (indicator.type === 'arrow' ? INDICATOR_BASE_RANGE_ARROW : INDICATOR_BASE_RANGE_FIELD) * (indicator.rangeScale || 1.0);

                     indicatorText = `<h4>Indicador Selec. (${indicator.type})</h4>`;
                     indicatorText += `<p><strong>Direção:</strong> (${indicatorForward.x.toFixed(2)}, ${indicatorForward.z.toFixed(2)})</p>`;
                     indicatorText += `<p><strong>Alcance/Intens.:</strong> ${indicatorRange.toFixed(1)} u.</p>`;

                     // Checar quem está na mira deste indicador
                     let targetsInView = [];
                     representatives.forEach(otherRep => {
                         if (otherRep === selectedRepresentative) return;
                         const directionToOther = otherRep.position.clone().sub(pos).normalize(); // Vetor do rep selecionado para o outro
                         const dotProduct = indicatorForward.dot(directionToOther);

                         // Definir um ângulo de visão (ex: 60 graus = cos(30) ~ 0.866)
                         const angleThreshold = (indicator.type === 'field') ? Math.cos(Math.PI / 6) : 0.95; // Campo mais largo, seta mais focada

                         if (dotProduct > angleThreshold) {
                             const distToOther = pos.distanceTo(otherRep.position);
                             if (distToOther <= indicatorRange) { // Verifica se está dentro do alcance
                                 targetsInView.push(`${otherRep.userData.label} (${distToOther.toFixed(1)} u)`);
                             }
                         }
                     });
                     if (targetsInView.length > 0) {
                        indicatorText += `<p><strong>Na Mira:</strong> ${targetsInView.join(', ')}</p>`;
                     } else {
                        indicatorText += `<p><strong>Na Mira:</strong> Ninguém</p>`;
                     }
                }
            }
            indicatorInfoDiv.innerHTML = indicatorText;

            // Garante que o painel principal esteja visível
            selectedControlsDiv.style.display = 'block';
        }
		
		// --- Funções para Exercícios ---
         function populateExerciseSelect() { /* (Inalterado - Parte 5) */
             exerciseSelect.innerHTML = '<option value="free">Exploração Livre</option>';
             for (const key in exercises) {
                 const option = document.createElement('option');
                 option.value = key;
                 option.textContent = `${exercises[key].name} (${exercises[key].reps} reps)`;
                 exerciseSelect.appendChild(option);
             }
         }
         function updateExerciseInfo() { /* (Inalterado - Parte 5) */
             const selectedKey = exerciseSelect.value;
             if (selectedKey === 'free') {
                 exerciseInfoDiv.innerHTML = "Modo de exploração livre.";
                 startExerciseBtn.disabled = true; startExerciseBtn.textContent = "Iniciar Exercício";
             } else if (exercises[selectedKey]) {
                 const ex = exercises[selectedKey];
                 exerciseInfoDiv.innerHTML = `<strong>${ex.name} (${ex.reps} reps):</strong> ${ex.description}`;
                 startExerciseBtn.disabled = inExerciseMode; startExerciseBtn.textContent = "Iniciar Exercício";
             } else {
                 exerciseInfoDiv.innerHTML = "Selecione um exercício."; startExerciseBtn.disabled = true; startExerciseBtn.textContent = "Iniciar Exercício";
             }
             if (inExerciseMode && selectedKey !== currentExercise && selectedKey !== 'free') { endExercise(); }
         }
         function startExercise() { /* (Inalterado - Parte 5 - já usa a createPawn correta e não ajusta Y) */
             const selectedKey = exerciseSelect.value;
             if (selectedKey === 'free' || !exercises[selectedKey]) return;
             if (representatives.length > 0) {
                 if (!confirm("Deseja limpar os representantes atuais?")) { return; }
                 removeAllRepresentatives();
             }
             currentExercise = selectedKey; currentStepIndex = 0; inExerciseMode = true;
             guidanceTitle.textContent = `Guia: ${exercises[currentExercise].name}`;
             showGuidanceStep(currentStepIndex);
             guidancePanel.classList.add('visible');
             startExerciseBtn.textContent = "Exercício em Andamento"; startExerciseBtn.disabled = true; exerciseSelect.disabled = true;
             console.log(`Iniciando exercício: ${currentExercise}`);
             if (currentExercise === 'timeline') {
                 timelineMarkers.nascimento = createPawnRepresentative("Nascimento", new THREE.Vector3(0, 0, -30), 0xaaaaaa);
                 timelineMarkers.futuro = createPawnRepresentative("Futuro", new THREE.Vector3(0, 0, 30), 0xaaaaaa);
                 if(timelineMarkers.nascimento) { timelineMarkers.nascimento.userData.isLocked = true; }
                 if(timelineMarkers.futuro) { timelineMarkers.futuro.userData.isLocked = true; }
             }
         }
         function endExercise() { /* (Inalterado - Parte 5) */
             inExerciseMode = false; currentExercise = null; currentStepIndex = 0;
             guidancePanel.classList.remove('visible');
             closeAnalysisModal();
             exerciseSelect.value = 'free'; exerciseSelect.disabled = false;
             updateExerciseInfo();
             if (timelineMarkers.nascimento) { const idxN = representatives.indexOf(timelineMarkers.nascimento); if (idxN > -1) representatives.splice(idxN, 1); scene.remove(timelineMarkers.nascimento); }
             if (timelineMarkers.futuro) { const idxF = representatives.indexOf(timelineMarkers.futuro); if (idxF > -1) representatives.splice(idxF, 1); scene.remove(timelineMarkers.futuro); }
             timelineMarkers = {};
             console.log("Exercício finalizado.");
         }
         function showGuidanceStep(stepIndex) { /* (Inalterado - Parte 5) */
             if (!inExerciseMode || !currentExercise || !exercises[currentExercise]) return;
             const exercise = exercises[currentExercise]; const steps = exercise.steps;
             if (stepIndex < 0 || stepIndex >= steps.length) return;
             currentStepIndex = stepIndex;
             guidanceContent.innerHTML = `<p><strong>Passo ${stepIndex + 1}:</strong> ${steps[stepIndex]}</p>`;
             stepCounterSpan.textContent = `Passo ${stepIndex + 1} / ${steps.length}`;
             const isLastStep = stepIndex === steps.length - 1;
             prevStepBtn.disabled = stepIndex === 0;
             nextStepBtn.textContent = isLastStep ? "Analisar Disposição" : "Próximo";
             nextStepBtn.disabled = false;
         }
         function handleNextStepOrAnalyze() { /* (Inalterado - Parte 5) */
              if (!inExerciseMode || !currentExercise) return;
              const exercise = exercises[currentExercise]; const steps = exercise.steps;
              const isLastStep = currentStepIndex === steps.length - 1;
              if (isLastStep) {
                  analyzeDisposition();
                  nextStepBtn.disabled = true; nextStepBtn.textContent = "Análise Exibida";
              } else {
                  if (currentStepIndex < steps.length - 1) { showGuidanceStep(currentStepIndex + 1); }
              }
         }
         function prevGuidanceStep() { /* (Inalterado - Parte 5) */
              if (currentStepIndex > 0) { showGuidanceStep(currentStepIndex - 1); }
         }

         // --- Função de Análise (Atualizada para mencionar indicadores) ---
         function analyzeDisposition() {
             console.log("Analisando disposição...");
             let analysisHTML = `<ul>`;
             const voce = representatives.find(r => r.userData.label.toLowerCase() === 'você' || r.userData.label.toLowerCase() === 'eu');
             const pai = representatives.find(r => r.userData.label.toLowerCase() === 'pai');
             const mae = representatives.find(r => r.userData.label.toLowerCase() === 'mãe');

             // --- Análise Geral (mantida) ---
             if (!voce) {
                 analysisHTML += "<li>Representante 'Você' não encontrado para análise detalhada.</li>";
             } else {
                 const scaleVoce = voce.userData.currentScale || 1.0;
                 analysisHTML += `<li>'Você' está com tamanho <strong>${scaleVoce.toFixed(1)}x</strong>.</li>`;
                 const proxThreshold = 3.0 * scaleVoce; const distThreshold = 15.0 * scaleVoce;
                 if (pai) { const distPai = voce.position.distanceTo(pai.position); if (distPai < proxThreshold) analysisHTML += `<li>Proximidade com 'Pai' (${distPai.toFixed(1)} u) sugere forte conexão ou emaranhamento.</li>`; else if (distPai > distThreshold) analysisHTML += `<li>Distância de 'Pai' (${distPai.toFixed(1)} u) sugere necessidade de conexão ou separação.</li>`;}
                 if (mae) { const distMae = voce.position.distanceTo(mae.position); if (distMae < proxThreshold) analysisHTML += `<li>Proximidade com 'Mãe' (${distMae.toFixed(1)} u) sugere forte vínculo ou dificuldade na individuação.</li>`; else if (distMae > distThreshold) analysisHTML += `<li>Distância de 'Mãe' (${distMae.toFixed(1)} u) sugere busca por autonomia ou ferida.</li>`;}
                 const forwardVoce = new THREE.Vector3(0, 0, -1).applyQuaternion(voce.quaternion).normalize();
                 if (pai) { const dirToPai = pai.position.clone().sub(voce.position).normalize(); const dotPai = forwardVoce.dot(dirToPai); if (dotPai > 0.85) analysisHTML += `<li>Olhando para 'Pai': busca por reconhecimento, apoio ou confronto?</li>`; else if (dotPai < -0.85) analysisHTML += `<li>De costas para 'Pai': negação, corte ou movimento para a vida?</li>`;}
                 if (mae) { const dirToMae = mae.position.clone().sub(voce.position).normalize(); const dotMae = forwardVoce.dot(dirToMae); if (dotMae > 0.85) analysisHTML += `<li>Olhando para 'Mãe': busca por nutrição, segurança ou resolução?</li>`; else if (dotMae < -0.85) analysisHTML += `<li>De costas para 'Mãe': autonomia ou dificuldade em receber?</li>`;}
                 if (pai && mae && currentExercise === 'ordem') { const avgParentZ = (pai.position.z + mae.position.z) / 2; if (voce.position.z > avgParentZ + 1) { analysisHTML += `<li>Posição atrás dos pais sugere lugar de filho(a).</li>`; } else if (voce.position.z < avgParentZ - 1) { analysisHTML += `<li>Posição à frente dos pais pode indicar inversão de papéis.</li>`; }}
             }
             let isolated = []; let isGrouped = true; const isolationThresholdBase = 15.0; const groupingThresholdBase = 10.0;
             if (representatives.length > 2) { representatives.forEach(rep => { let minDistToOther = Infinity; const repScale = rep.userData.currentScale || 1.0; representatives.forEach(other => { if (rep !== other) { minDistToOther = Math.min(minDistToOther, rep.position.distanceTo(other.position)); }}); if (minDistToOther > isolationThresholdBase * repScale) { isolated.push(rep.userData.label); isGrouped = false; } if(minDistToOther > groupingThresholdBase * repScale) { isGrouped = false; }}); } else { isGrouped = false; }
             if (isolated.length > 0) { analysisHTML += `<li>Representantes isolados: ${isolated.join(', ')}.</li>`; } else if (isGrouped && representatives.length > 2) { analysisHTML += `<li>Representantes agrupados: coesão ou falta de espaço individual?</li>`; }

             // --- Análise dos Indicadores (Simplificada) ---
             analysisHTML += `<li><strong>Análise de Indicadores:</strong></li>`;
             let hasIndicators = false;
             representatives.forEach(rep => {
                 if (rep.userData.indicators && rep.userData.indicators.length > 0) {
                     hasIndicators = true;
                     analysisHTML += `<ul><li><strong>${rep.userData.label}:</strong></li><ul>`;
                     rep.userData.indicators.forEach((indicator, index) => {
                         const indicatorWorldQuaternion = new THREE.Quaternion();
                         indicator.object3D.getWorldQuaternion(indicatorWorldQuaternion);
                         const indicatorForward = new THREE.Vector3(0, 0, -1).applyQuaternion(indicatorWorldQuaternion).normalize();
                         const indicatorRange = (indicator.type === 'arrow' ? INDICATOR_BASE_RANGE_ARROW : INDICATOR_BASE_RANGE_FIELD) * (indicator.rangeScale || 1.0);
                         let targets = [];
                         representatives.forEach(otherRep => {
                             if (otherRep === rep) return;
                             const directionToOther = otherRep.position.clone().sub(rep.position).normalize();
                             const dot = indicatorForward.dot(directionToOther);
                             const angleThresh = (indicator.type === 'field') ? Math.cos(Math.PI / 6) : 0.95;
                             if (dot > angleThresh && rep.position.distanceTo(otherRep.position) <= indicatorRange) {
                                 targets.push(otherRep.userData.label);
                             }
                         });
                         analysisHTML += `<li>Indicador ${index+1} (${indicator.type}): Alcance ${indicatorRange.toFixed(1)}u. ${targets.length > 0 ? `Apontando para: ${targets.join(', ')}.` : 'Não aponta diretamente para outros.'}</li>`;
                     });
                     analysisHTML += `</ul></ul>`;
                 }
             });
             if (!hasIndicators) {
                 analysisHTML += `<li>Nenhum indicador de direção/ação foi adicionado.</li>`;
             } else {
                 analysisHTML += `<li>Reflita sobre o significado das direções, alcances e alvos dos indicadores adicionados.</li>`;
             }


             analysisHTML += "</ul>";
             analysisContent.innerHTML = analysisHTML;
             analysisModal.classList.add('visible');
             guidancePanel.classList.remove('visible');
         }

         function closeAnalysisModal() { /* (Inalterado - Parte 5) */
             analysisModal.classList.remove('visible');
             if (inExerciseMode) { endExercise(); }
         }


         // --- Loop de Animação e Redimensionamento ---
         function animate() { /* (Inalterado - Parte 5) */
             requestAnimationFrame(animate);
             const delta = clock.getDelta();
             let moveForward = (moveState.forward ? 1 : 0) + (moveState.backward ? -1 : 0);
             let moveRight = (moveState.right ? 1 : 0) + (moveState.left ? -1 : 0);
             if (moveForward !== 0 || moveRight !== 0) {
                 const cameraDirection = new THREE.Vector3(); camera.getWorldDirection(cameraDirection); cameraDirection.y = 0; cameraDirection.normalize();
                 const cameraRight = new THREE.Vector3(); cameraRight.crossVectors(camera.up, cameraDirection).normalize();
                 const moveVector = new THREE.Vector3(); moveVector.addScaledVector(cameraDirection, moveForward); moveVector.addScaledVector(cameraRight, -moveRight);
                 if (moveForward !== 0 && moveRight !== 0) { moveVector.normalize(); }
                 const moveAmount = MOVE_SPEED * 15 * delta; moveVector.multiplyScalar(moveAmount);
                 camera.position.add(moveVector); controls.target.add(moveVector);
             }
             controls.update();
             renderer.render(scene, camera);
         }

         function onWindowResize() { /* (Inalterado - Parte 5) */
             camera.aspect = window.innerWidth / window.innerHeight;
             camera.updateProjectionMatrix();
             renderer.setSize(window.innerWidth, window.innerHeight);
         }

         // --- Iniciar ---
         init();

    </script>
</body>
</html>
